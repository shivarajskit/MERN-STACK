---------------------------------
1. CRUD Operations
----------------------------------

Insert
// Insert one
db.users.insertOne({ name: "Alice", age: 25, email: "alice@mail.com" });

// Insert many
db.users.insertMany([
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 28 }
]);

Read
// Find all
db.users.find();

// Find with condition
db.users.find({ age: { $gt: 25 } });

// Projection (return only certain fields)
db.users.find({}, { name: 1, email: 1 });

Update
// Update one
db.users.updateOne(
  { name: "Alice" },
  { $set: { age: 26 } }
);

// Update many
db.users.updateMany(
  { age: { $lt: 30 } },
  { $inc: { age: 1 } } // increase age by 1
);

Delete
db.users.deleteOne({ name: "Bob" });
db.users.deleteMany({ age: { $gt: 40 } });


ðŸ‘‰ Practice:

Build a users collection.

Perform full CRUD cycle (insert â†’ read â†’ update â†’ delete).

Add queries with conditions like $in, $or, $regex.

-----------------------------------------------
2. Indexing
-------------------------------------------------

Indexes make queries faster but have trade-offs.

Default

Every document automatically gets an _id index.

Create Index
db.users.createIndex({ email: 1 }); // ascending
db.users.createIndex({ name: -1 }); // descending

Compound Index
db.users.createIndex({ age: 1, city: -1 });

Check Index Usage
db.users.find({ email: "alice@mail.com" }).explain("executionStats");


ðŸ‘‰ Interview Tip:

Indexes speed up reads but slow writes.

Use them for fields you query often.

Avoid creating too many.

-------------------------------------------
3. Aggregation Framework
----------------------------------------------

Used for advanced queries (like SQL GROUP BY).

Example 1 â€“ Group & Count
db.orders.aggregate([
  { $group: { _id: "$userId", totalOrders: { $sum: 1 } } }
]);

Example 2 â€“ Average Age of Users
db.users.aggregate([
  { $group: { _id: null, avgAge: { $avg: "$age" } } }
]);

Example 3 â€“ Sort & Limit
db.users.aggregate([
  { $sort: { age: -1 } },
  { $limit: 5 }
]);


ðŸ‘‰ Interview Tip:

Aggregation pipeline = multiple stages ($match, $group, $project).

Much more powerful than .find().

-------------------------------------------
4. Schema Design
------------------------------------------------

MongoDB is schema-less, but good design matters.

Embedding
{
  name: "Alice",
  orders: [
    { product: "Laptop", price: 1000 },
    { product: "Mouse", price: 20 }
  ]
}


âœ… Faster reads (one query)
âŒ Grows big quickly

Referencing
// users
{ _id: 1, name: "Alice" }

// orders
{ _id: 101, userId: 1, product: "Laptop" }


âœ… Flexible, avoids duplication
âŒ Requires multiple queries (or populate in Mongoose)

Relationships

One-to-One â†’ embed small docs.

One-to-Many â†’ reference large collections.

Many-to-Many â†’ use references + join logic.

ðŸ‘‰ Practice:

Design schemas for an E-commerce App:

users

products

orders (connects users & products)


-------------------------------------------------------------------------------------
ðŸ”¥ MongoDB Q&A with Answers
---------------------------------------------------------------------------------------

1. Difference between findOne() and find()?

findOne() â†’ Returns the first matching document (or null if none).

find() â†’ Returns a cursor to all matching documents (can loop, use .toArray()).
ðŸ‘‰ Use findOne() for a single doc lookup (like login by email).
ðŸ‘‰ Use find() when you expect multiple results (like all orders of a user).

2. How does indexing improve query performance?

Without index â†’ MongoDB does a collection scan (checks every document).

With index â†’ MongoDB looks up the value in a sorted index structure (like a book index).
ðŸ‘‰ Makes reads & queries faster, especially for large datasets.
âš ï¸ Tradeoff â†’ Slower writes (insert/update/delete) + more storage.

3. Difference between updateOne() vs updateMany()?

updateOne(filter, update) â†’ Updates the first document matching the filter.

updateMany(filter, update) â†’ Updates all documents matching the filter.

Example:

db.users.updateOne({ age: { $gt: 25 } }, { $set: { status: "Active" } }); // 1 user
db.users.updateMany({ age: { $gt: 25 } }, { $set: { status: "Active" } }); // all users >25

4. What is the Aggregation pipeline?

A data processing framework in MongoDB.

Processes documents in stages ($match, $group, $sort, $project).

Similar to SQL GROUP BY + HAVING + JOIN + ORDER BY.

Example: Count orders per user:

db.orders.aggregate([
  { $group: { _id: "$userId", totalOrders: { $sum: 1 } } }
]);

5. When would you embed vs reference documents?

Embed (nesting data inside doc) â†’ When data is small, tightly coupled, and queried together.
Example: user + address.

Reference (separate collection, use _id) â†’ When data is large, reused, or loosely coupled.
Example: users and orders.

ðŸ‘‰ Rule of thumb:

Embed for one-to-few, frequently accessed together.

Reference for one-to-many or many-to-many, large data.

6. SQL vs NoSQL schema design differences?

SQL (Relational)

Fixed schema (tables, columns).

Normalization (avoid duplication).

Joins across tables.

NoSQL (MongoDB)

Flexible schema (JSON-like docs).

Denormalization (sometimes duplicate data for performance).

Joins are rare (use embedding or populate).

ðŸ‘‰ SQL = consistency, structure.
ðŸ‘‰ NoSQL = flexibility, scalability.

7. How to optimize MongoDB queries in a large dataset?

Create indexes on frequently queried fields.

Use projection to fetch only needed fields (find({}, { name: 1 })).

Use pagination (limit + skip) instead of loading everything.

Use aggregation pipeline instead of multiple queries.

Avoid $regex without prefix (canâ€™t use index).

Use sharding for very large datasets.

8. What are capped collections?

Fixed-size collections in MongoDB.

When full â†’ oldest documents are overwritten automatically.

Useful for logging, caching, real-time data (like sensor data).

Example:

db.createCollection("logs", { capped: true, size: 10000, max: 1000 });

-------------------------------------------------------------------------------------